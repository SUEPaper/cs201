---
id: hog
sidebar_position: 2
---

# The Game of Hog

本实验项目搬运自加州大学伯克利分校的CS61A课程的[Hog项目](https://cs61a.org/proj/hog/)。

:::tip 温馨小提示

我们知道CS61A是一门世界知名的计算机编程入门课程，相关课程实验和项目网上都有答案，
但是请遵守学术诚信原则，自己动手完成所有的实验，这样你才能得到足够的训练，
掌握Python这门语言，为后续的实践课程打下坚实的基础。

:::

# **项目 1：CS 61A 猪的游戏**

- [**hog.zip**](https://cs61a.org/proj/hog/hog.zip)

## Hog 规则

在游戏 "Hog" 中，两名玩家轮流尝试成为首个在一轮结束时至少累积100分的玩家。在每个轮次中，当前玩家选择要投掷的骰子数量，最多不超过10个。该玩家本轮的得分是投掷骰子结果的总和。然而，投掷过多骰子的玩家可能会面临以下风险,以及为了让游戏更加有趣，我们将加入一些特殊规则：

1、Sow Sad：如果任何一个骰子的结果是1，当前玩家本轮的得分将为1分。
- eg 1：当前玩家投掷了7个骰子，其中有5个是1。他们在这一轮中得分1分。
- eg 2：当前玩家投掷了4个骰子，全部为3。由于没有发生Sow Sad，他们在这一轮中得分12分。
  
2、Piggy Points：选择不投掷任何骰子的玩家得分为 k+3 分，其中 k 是对手得分平方中最小数字。
- eg 1：当前玩家选择不投掷任何骰子，对手得分为4。4 ** 2 = 16，因此当前玩家将获得3 + 1 = 4分。
- eg 2：当前玩家选择不投掷任何骰子，对手得分为10。10 ** 2 = 100，因此当前玩家将获得3 + 0 = 3分。
- eg 3：当前玩家选择不投掷任何骰子，对手得分为94。94 ** 2 = 8836，因此当前玩家将获得3 + 3 = 6分。
- eg 4：当前玩家选择不投掷任何骰子，对手得分为0。0 ** 2 = 0，因此当前玩家将获得3 + 0 = 3分。
  
3、More Boar：首先，将本轮得分加到当前玩家的分数上。然后，如果当前玩家的分数的最左边一位数字小于对手分数的最左边一位数字，并且当前玩家的分数的第二左边一位数字小于对手分数的第二左边一位数字，则当前玩家可以再进行一次轮次。如果任何一方的分数只有一位数字，则假设在其前面加一个0（例如，1 -> 01，6 -> 06）。请注意，不能假设分数在100以下。在将本轮得分加到当前玩家的分数后，应执行“More Boar”计算。
- eg 1：在加分后，当前玩家的分数为21，对手的分数为43。因为2 < 4，并且1 < 3，所以当前玩家可以再进行一次轮次。
- eg 2：在加分后，当前玩家的分数为32，对手的分数为33。由于当前玩家的最左边一位数字不严格较小（3 = 3），所以当前玩家不会再进行另一次轮次。
- eg 3：在加分后，当前玩家的分数为7，对手的分数为10。因为当前玩家的第二左边一位数字不小（7 > 0），所以当前玩家不会再进行另一次轮次。
- eg 4：在加分后，当前玩家的分数为21，对手的分数为43。就像示例1一样，当前玩家可以再进行一次轮次。如果随后当前玩家投掷了一个1，现在的分数为22，那么“More Boar”再次激活，当前玩家会再次进行另一次轮次。

## 最终成果
我们的项目解决方案可以在[hog.cs61a.org](https://hog.cs61a.org/)上进行游玩 — 试试看吧！完成这个项目后，您将自己实现了这个游戏的重要部分。

## 下载入门文件
要开始，请将所有项目代码下载为一个[zip归档](https://cs61a.org/proj/hog/hog.zip)文件。以下是归档文件中的所有文件列表。但是，您只需要对hog.py进行更改。
- hog.py：Hog的初始实现
- dice.O
- hog_gui.py：Hog的图形用户界面（GUI）
- ucb.py：CS 61A的实用函数
- ok：CS 61A自动分级程序
- tests：由ok使用的测试目录
- gui_files：Web GUI使用的各种文件目录

## 项目细节
您需要提交以下文件：
- hog.py
  
您无需修改或提交任何其他文件即可完成项目。要提交项目，请运行以下命令：
```python
python ok -q [题号] -i
```
对于我们要求您完成的函数，可能会有一些我们提供的初始代码。如果您不想使用该代码，可以随意删除它，然后从头开始编写。您也可以根据需要添加新的函数定义。

但是，请不要修改任何其他函数。这样做可能会导致您的代码无法通过我们的自动分级测试。此外，请不要更改任何函数的签名（名称、参数顺序或参数数量）。

在整个项目中，您应该测试代码的正确性。经常进行测试是一个好习惯，这样可以更容易地隔离出任何问题。但是，您不应该过于频繁地进行测试，以便有时间思考问题。

我们提供了一个名为ok的自动分级工具，可以帮助您测试代码并跟踪进度。第一次运行自动分级工具时，系统会要求您使用Web浏览器使用您的Ok账号登录。请按照提示操作。每次运行ok时，它都会将您的工作和进度备份到我们的服务器上。

ok的主要目的是测试您的实现。

如果您不希望我们记录您的工作备份或有关您进度的信息，您可以在本地运行。
```python
python ok --local
```

:::caution

由于我们未和加州大学伯克利分校CS61A课程组达成战略合作关系，
同时也未将其开源的OJ(在线评测系统)部署一个自己的系统。强烈推荐大家使用本地运行模式

```python
python ok --local
```

**你应该庆幸这样，如果有了在线OJ系统，那对大家的成绩是有具体自动评分系统，也会相关的防作弊系统。这不意味着你可以不遵守学术诚信原则。**
:::

使用此选项，不会将任何信息发送到我们的课程服务器。如果要进行交互式测试，可以运行以下命令：
```python
python ok -q [问题编号] -i
```
将适当的问题编号（例如01）插入其中。这将运行该问题的测试，直到您第一次失败，然后让您有机会进行交互式地测试您编写的函数。

您还可以使用OK中的调试打印功能，方法是编写：
```python
print("DEBUG:", x)
```
这将在您的终端产生一个输出，而不会导致OK测试失败并出现额外的输出。

## 图形用户界面
我们为您提供了一个图形用户界面（GUI）。目前，由于您尚未实现游戏逻辑，它尚未工作。一旦您完成了play函数，您就可以玩一个完全交互式的Hog版本！

完成后，您可以从终端运行GUI：
```python
python hog_gui.py
```
该GUI是托管在GitHub上的开源项目。

## 阶段1：模拟器
在第一阶段，您将开发一个Hog游戏的模拟器。
### 问题0
dice.py文件使用非纯零参数函数表示骰子。这些函数是非纯的，因为它们每次被调用时可能会有不同的返回值。dice.py的文档描述了项目中使用的两种不同类型的骰子：

公平骰子以相等的概率产生每个可能的结果。两个公平骰子已经定义好，即four_sided和six_sided，并由make_fair_dice函数生成。
测试骰子是确定性的：它始终会在作为参数传递的固定序列的值之间循环。测试骰子由make_test_dice函数生成。
在编写任何代码之前，请阅读dice.py文件，并通过解锁以下测试来检查您的理解。
```python
python ok -q 00 -u
```
这应该显示一个类似于以下的提示：
```python
=====================================================================
Assignment: Project 1: Hog
Ok, version v1.5.2
=====================================================================

~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Unlocking tests

At each "? ", type what you would expect the output to be.
Type exit() to quit

---------------------------------------------------------------------
Question 0 > Suite 1 > Case 1
(cases remaining: 1)

>>> test_dice = make_test_dice(4, 1, 2)
>>> test_dice()
?
```
你应该输入你的输出结果。为了做到这一点，你需要首先弄清楚根据上述描述，test_dice 会执行什么操作。

你可以通过输入 exit() 来退出解锁器。在Windows上按下 Ctrl-C 退出解锁器可能会导致问题，所以请避免使用这种方式。
### 问题 1
在 hog.py 中实现 roll_dice 函数。它接受两个参数：一个名为 num_rolls 的正整数，表示要投掷的骰子数量，以及一个投掷骰子的函数。函数应返回在一轮中投掷指定次数的骰子后获得的总点数：要么是所有结果的总和，要么是 1（Sow Sad）。
:::tip

Sow Sad 规则：

如果任何一个骰子的结果为1，则当前玩家本轮的得分为1
- eg 1：当前玩家投掷了7个骰子，其中5个骰子的点数为1。他们本轮得分为1分。
- eg 2：当前玩家投掷了4个骰子，全部为3点。由于未出现悲喜豆，他们本轮得分为12分。
:::

要获得一次骰子投掷的单个结果，请调用 dice()。在 roll_dice 函数体内，您应该恰好调用 dice() 一共 num_rolls 次。即使在投掷过程中发生了 悲喜豆，也应该确保恰好调用 dice() num_rolls 次。通过这种方式，您可以正确模拟同时投掷所有的骰子。

理解问题：

在编写任何代码之前，解锁测试以验证您对问题的理解。注意：在解锁相应问题的测试用例之前，您将无法使用 OK 来测试您的代码。
```python
python ok -q 01 -u
```
编写代码并检查您的工作：

解锁完成后，开始实现您的解决方案。您可以使用以下方法检查您的正确性：
```python
python ok -q 01
```
:::tip
debug
如果测试未通过，那么现在是进行调试的时候了。您可以使用 Python 直接观察您的函数行为。首先，启动 Python 解释器并加载 hog.py 文件。
```python
python -i hog.py
```
接下来，您可以在任意数量的骰子上调用您的 roll_dice 函数。roll_dice 函数有一个名为 dice 的默认参数值，它是一个六面的随机骰子函数。因此，以下对 roll_dice 的调用模拟了投掷四个公平的六面骰子：
```python
>>> roll_dice(4)
```
您会发现，之前的表达式在每次调用时可能会产生不同的结果，因为它模拟了随机的骰子投掷。您还可以使用预先固定骰子结果的测试骰子。例如，在您知道骰子将投掷出3和4的情况下进行两次投掷，应该会得到总结果为7。
```python
>>> fixed_dice = make_test_dice(3, 4)
>>> roll_dice(2, fixed_dice)
7
```
在大多数系统上，您可以通过按上箭头键再次评估相同的表达式，然后按下回车键。要评估先前的命令，请重复按上箭头键。

如果您发现问题，您需要更改您的 hog.py 文件，保存它，退出 Python，然后重新启动 Python，然后开始评估表达式。即使在重新启动 Python 后，按上箭头键也应该可以让您访问先前的表达式。

继续调试您的代码并运行 ok 测试，直到它们全部通过。对于此项目中的所有问题，您应该遵循相同的流程：理解问题、实现解决方案、测试和调试。

另一个调试提示：为了在 ok 测试失败时自动启动交互式解释器，请使用 -i。例如，python3 ok -q 01 -i 将运行问题1的测试，如果测试失败，则会启动一个带有加载的 hog.py 的交互式解释器。
:::
### 问题 2
实现 piggy_points 函数，该函数接受对手的当前得分，并返回通过投掷0个骰子获得的点数。

Piggy Points 规则:

选择投掷零个骰子的玩家将获得 k+3 分，其中 k 是对手得分的平方中最小的数字。
- eg 1：当前玩家投掷零个骰子，对手得分为 4。4 ** 2 = 16，因此当前玩家将获得 3 + 1 = 4 分。
- eg 2：当前玩家投掷零个骰子，对手得分为 10。10 ** 2 = 100，因此当前玩家将获得 3 + 0 = 3 分。
- eg 3：当前玩家投掷零个骰子，对手得分为 94。94 ** 2 = 8836，因此当前玩家将获得 3 + 3 = 6 分。
- eg 4：当前玩家投掷零个骰子，对手得分为 0。0 ** 2 = 0，因此当前玩家将获得 3 + 0 = 3 分。

您可以按照您希望的任何方式实现此函数，只要您的实现中不使用 for 循环或方括号 []。您不必遵循此推荐方法或使用提供的起始代码。

在编写任何代码之前，解锁测试以验证您对问题的理解。
```python
python ok -q 02 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下方法检查您的正确性：
```python
python ok -q 02 
```
您还可以通过在终端中输入 python -i hog.py，然后使用不同的输入调用 piggy_points 来交互式地测试 piggy_points。

### 问题 3
实现 take_turn 函数，该函数通过投掷给定的骰子 num_rolls 次返回一个回合的得分。

在可能的情况下，您的 take_turn 实现应同时调用 roll_dice 和 piggy_points。

在编写任何代码之前，解锁测试以验证您对问题的理解。
```python
python ok -q 03 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查您的正确性：
```python
python ok -q 03
```
### 问题 4
实现 more_boar 函数，该函数接受当前玩家和对手的得分，并返回当前玩家是否因为“More Boar”而进行另一轮。

More Boar 规则:

首先，将本回合的得分加到当前玩家的得分中。然后，如果当前玩家的得分的最左边一位数字小于对手的得分的最左边一位数字，且当前玩家的得分的第二左边一位数字小于对手的得分的第二左边一位数字，则当前玩家将进行另一轮。如果任一得分只有一位数字，则假设其前面有一个0（例如，1 -> 01，6 -> 06）。您不能假设得分在100以下。“More Boar”的计算应在将本回合的得分添加到当前玩家的得分后进行。
- eg 1：在加分后，当前玩家的分数为21，对手的分数为43。因为2 < 4，并且1 < 3，所以当前玩家可以再进行一次轮次。
- eg 2：在加分后，当前玩家的分数为32，对手的分数为33。由于当前玩家的最左边一位数字不严格较小（3 = 3），所以当前玩家不会再进行另一次轮次。
- eg 3：在加分后，当前玩家的分数为7，对手的分数为10。因为当前玩家的第二左边一位数字不小（7 > 0），所以当前玩家不会再进行另一次轮次。
- eg 4：在加分后，当前玩家的分数为21，对手的分数为43。就像示例1一样，当前玩家可以再进行一次轮次。如果随后当前玩家投掷了一个1，现在的分数为22，那么“More Boar”再次激活，当前玩家会再次进行另一次轮次。
在编写任何代码之前，解锁测试以验证您对问题的理解。
```python
python ok -q 04 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查您的正确性：
```python
python ok -q 04
```

### 问题 5
实现 play 函数，该函数模拟了一局完整的豚游戏。玩家轮流掷骰子，直到其中一名玩家达到目标分数。

一次回合被定义为一次掷骰子，因为同一玩家可以连续进行多轮。

为了确定每回合掷骰子的次数，每个玩家都使用他们各自的策略（玩家0使用 strategy0，玩家1使用 strategy1）。策略是一个函数，给定玩家的得分和对手的得分，返回当前玩家在回合中将投掷的骰子数量。暂时不用担心实现策略；这将在第三阶段完成。

当游戏结束时，play 返回两名玩家的最终总分，玩家0的分数排在前面，玩家1的分数排在后面。
:::tip
重要提示：每个策略函数在每轮中应该仅被调用一次。这意味着当轮到玩家0时只调用 strategy0，轮到玩家1时只调用 strategy1。否则，图形界面和一些 ok 测试可能会混淆。

提示：
- 您应该调用已经实现的函数。
- 调用 take_turn 时传入四个参数（不要忘记传入目标得分）。每回合只调用一次 take_turn。
- 调用 more_boar 来确定当前玩家是否因为“More Boar”而进行另一轮。
- 您可以通过调用提供的函数 next_player 来获取下一位玩家的编号（可以是 0 或 1）。
- 您暂时可以忽略 play 函数的 say 参数。您将在项目的第二阶段使用它。
:::
__规则澄清__：玩家可以连续进行多于两轮的回合。例如，如果第一轮后的得分是10比55，由于“More Boar”，他们再次轮到。如果他们得分4分，现在的得分是14比55，他们由于“More Boar”再次进行第三轮。如果他们得分20分，现在的得分是34比55，他们连续进行第四轮。

在编写任何代码之前，解锁测试以验证您对问题的理解。
```python
python ok -q 05 -u
```
解锁完成后，开始实现您的解决方案。您可以使用以下命令检查您的正确性：
```python
python ok -q 05
```
一旦你完成，你将能够玩游戏的图形版本。我们提供了一个名为hog_gui.py的文件，您可以从终端运行该文件：
```python
python hog_gui.py
```
GUI 依赖于您的实现，因此如果您的代码中有任何错误，它们将反映在 GUI 中。这意味着您还可以使用 GUI 作为调试工具；但是，最好先运行测试。

检查并确保您已完成第一阶段中的所有问题：
```python
python ok --score
```
恭喜！您已经完成了该项目的第一阶段！

## 阶段1：评论
在第二阶段，您将实现评论功能，在每回合后打印有关游戏的评论，例如，"Player 1 has reached a new maximum point gain. 22 point(s)!"

评论函数有两个参数：玩家 0 的当前得分和玩家 1 的当前得分。它可以根据当前分数及其父环境中的任何其他信息打印评论。由于评论可能会根据游戏中当前的得分情况而有所不同，因此评论函数总是返回另一个评论函数以在下一回合调用。注释功能的唯一副作用应该是打印。

### 注释示例
say_scores中的函数hog.py是评论函数的示例，它只是宣布两个玩家的得分。请注意，say_scores返回自身，这意味着每轮都会调用相同的注释函数。
```python
def say_scores(score0, score1):
    """A commentary function that announces the score for each player."""
    print("Player 0 now has", score0, "and Player 1 now has", score1)
    return say_scores
```
该函数announce_lead_changes是一个高阶函数的示例，它返回跟踪引导变化的注释函数。每回合都会调用不同的评论功能。
```python
def announce_lead_changes(last_leader=None):
    """Return a commentary function that announces lead changes.

    >>> f0 = announce_lead_changes()
    >>> f1 = f0(5, 0)
    Player 0 takes the lead by 5
    >>> f2 = f1(5, 12)
    Player 1 takes the lead by 7
    >>> f3 = f2(8, 12)
    >>> f4 = f3(8, 13)
    >>> f5 = f4(15, 13)
    Player 0 takes the lead by 2
    """
    def say(score0, score1):
        if score0 > score1:
            leader = 0
        elif score1 > score0:
            leader = 1
        else:
            leader = None
        if leader != None and leader != last_leader:
            print('Player', leader, 'takes the lead by', abs(score0 - score1))
        return announce_lead_changes(leader)
    return say
```
您还应该了解该函数both，它接受两个注释函数（f和g）并返回一个新的注释函数。这个返回的注释函数返回另一个注释函数，该函数按顺序调用通过调用f和g，返回的函数。
### 问题 6
更新您的play函数，以便在每回合结束时调用评论函数。调用注释函数的返回值会为您提供下一轮要调用的注释函数。

例如，say(score0, score1)应该在第一回合结束时调用。它的返回值（另一个注释函数）应该在第二轮结束时调用。每个连续回合，调用由调用前一回合的注释函数返回的函数。

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```python
python ok -q 06 -u
```
完成解锁后，开始实施您的解决方案。您可以通过以下方式检查您的正确性：
```python
python ok -q 06
```
### 问题 7
实现该announce_highest函数，该函数是一个返回注释函数的高阶函数。每当特定玩家在回合中获得比以往更多的分数时，此评论功能就会宣布。例如， announce_highest(1)完全忽略玩家 0，只打印有关玩家 1 的信息。（它的返回值也是如此；另一个仅关于玩家 1 的注释函数。）

要计算增益，它必须将last_score感兴趣的玩家（由 who参数指定）的上一回合 ( ) 的得分与本回合的得分进行比较。此函数还必须跟踪玩家迄今为止的最高增益，该增益存储为running_high.

公告的方式announce_highest非常具体，您的实现应该与提供的文档测试相匹配。在宣布积分增益时，不要担心单数还是复数；对于这两种情况，您应该简单地使用“point(s)”。
:::tip
提示：提供给您的功能announce_lead_changes是如何使用注释功能跟踪信息的示例。如果您遇到困难，请首先确保您了解announce_lead_changes其工作原理。
:::

:::tip
暗示。如果您收到local variable [var] reference before assignment错误：

发生这种情况是因为在 Python 中，通常不允许您修改父框架中定义的变量。解释[var]器认为您正在尝试在当前框架内定义一个新变量，而不是重新分配 。我们将在以后的讲座中了解如何解决这个问题，但这不是这个问题所必需的。

要解决此问题，您有两种选择：

1)与其将[var]重新分配给它的新值，不如创建一个新变量来保存这个新值。在将来的计算中使用该新变量。

2）具体针对这个问题，完全不使用赋值语句来完全避免这个问题。相反，将新值作为参数传递给announce_highest.
:::
在编写任何代码之前，请解锁测试以验证您对问题的理解。
```python
python ok -q 07 -u
```
完成解锁后，开始实施您的解决方案。您可以通过以下方式检查您的正确性：
```python
python ok -q 07
```
完成后，您将在 GUI 中看到注释：
```python
python hog_gui.py
```
GUI 中的注释是通过将以下函数作为 say参数传递给 来生成的play。
both(announce_highest(0), both(announce_highest(1), announce_lead_changes()))
做得好！您刚刚完成了该项目的第二阶段！

## 阶段1：策略
在第三阶段，您将尝试改进始终掷固定数量骰子的基本策略的方法。首先，您需要开发一些工具来评估策略。
### 问题 8
实现该函数，这是一个以函数作为参数的make_averaged高阶函数。它返回另一个函数，该函数采用与（最初传递给 的函数 ）original_function相同数量的参数。此返回函数与输入函数的不同之处在于，它返回重复调用相同参数的平均值。该函数应调用总共次数并返回结果的平均值。original_functionmake_averagedoriginal_functionoriginal_functiontrials_count

要实现这个功能，你需要一段新的Python语法！您必须编写一个接受任意数量参数的函数，然后使用这些参数调用另一个函数。这是它的工作原理。

您可以编写 ，而不是列出函数的形式参数*args。要完全使用这些参数调用另一个函数，您可以使用 再次调用它 *args。例如：
```python
>>> def printed(f):
...     def print_and_return(*args):
...         result = f(*args)
...         print('Result:', result)
...         return result
...     return print_and_return
>>> printed_pow = printed(pow)
>>> printed_pow(2, 8)
Result: 256
256
>>> printed_abs = printed(abs)
>>> printed_abs(-10)
Result: 10
10
```
仔细阅读文档字符串make_averaged以了解它的工作原理。

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```python
python ok -q 08 -u
```
完成解锁后，开始实施您的解决方案。您可以通过以下方式检查您的正确性：
```python
python ok -q 08
```
### 问题 9
实现该max_scoring_num_rolls函数，该函数运行实验来确定给出每轮最大平均得分的掷骰次数（从 1 到 10）。您的实现应该使用make_averaged和 roll_dice。

如果两个掷骰数的最大平均分数相同，则返回较低的数字。例如，如果 3 和 6 都达到了最大平均分数，则返回 3。

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```python
python ok -q 09 -u
```
运行实验：

要在随机骰子上运行此实验，请run_experiments使用以下-r选项调用：
```python
python hog.py -r
```
run_experiments对于该项目的其余部分，您可以根据需要更改实施。该函数包括用于评估各种 Hog 策略的调用 average_win_rate，但大多数调用目前已被注释掉。您可以取消注释来尝试策略的调用，例如将 的胜率 与 的always_roll(8)胜率进行比较always_roll(6)。

有些实验可能需要一分钟才能运行。您始终可以减少调用中的试验次数以make_averaged加快实验速度。

运行实验不会影响您在该项目上的得分。
### 问题10
策略可以尝试利用Piggy Points规则，在最有利的时候掷 0。Implement piggypoints_strategy，只要滚动 0至少 cutoff给出点，它就会返回 0，否则返回 num_rolls。

在编写任何代码之前，请解锁测试以验证您对问题的理解。
```python
python ok -q 10 -u
```
完成解锁后，开始实施您的解决方案。您可以通过以下方式检查您的正确性：
```python
python ok -q 10
```
实施此策略后，请run_experiments根据基线进行更改以评估新策略。是不是比直接滚4更好？
### 问题11
策略还可以利用更多More Boar 规则。如果触发另一回合，更多野猪策略总是掷 0。在其他情况下，如果滚动 0至少 cutoff可以得到分数，则滚动 0。否则，策略就会滚动num_rolls。
:::tip
提示piggypoints_strategy：您可以使用问题 10 中定义的函数

提示：请记住，应在将分数添加到分数more_boar后进行检查。piggy_points
:::
在编写任何代码之前，请解锁测试以验证您对问题的理解。
```python
python ok -q 11 -u
```
完成解锁后，开始实施您的解决方案。您可以通过以下方式检查您的正确性：
```python
python ok -q 11
```
一旦您实现了此策略，请更新run_experiments以根据基线评估您的新策略。你应该发现它比always_roll(6)有显著的优势。
### 可选：问题11
实施final_strategy，它将这些想法和任何其他想法结合起来，以实现该策略的高胜率always_roll(6)。一些建议：
- more_boar_strategy是一个很好的默认策略。
- 如果您知道目标得分（默认为 100），则得分超过目标是没有意义的。检查掷 0、1或 2 个骰子是否可以获胜。如果你处于领先地位，你可能会承担更少的风险。
- 尝试强行再次转弯。
- 仔细选择num_rolls和cutoff参数。
- 采取最有可能赢得比赛的行动。
您可以通过运行Ok来检查您的最终策略是否有效。
```python
python ok -q 12
```
您最终还可以通过运行来检查您确切的最终获胜率
```python
python calc.py
```
这应该会弹出一个窗口，要求您确认您的身份，然后它将打印出您最终策略的胜率。

您还可以使用图形用户界面来对抗您的最终策略：
```python
python hog_gui.py
```
GUI 将交替由您控制哪个玩家。

## 项目提交
此时，运行整个自动评分器，看看是否有任何测试未通过：
```python
python ok
```
您还可以检查您在项目每个部分的分数：
```python
python ok --score
```